#!/usr/bin/perl -w

##########################################################################
#
#    Neet: Network discovery, enumeration and security assessment tool
#    Copyright (C) 2008-2016 Jonathan Roach
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Contact: jonnyhightower [at] funkygeek.com
#
##########################################################################

# Ensure we can find our Perl modules
BEGIN {
	unshift @INC, "/opt/neet/core";
}

# Should only be called by neetsh

use strict;
use Term::ReadKey;
use JR::Files::Config;
use Neet::Logging;
use Neet::Util;
use Neet::VceConfig;
use Neet::CredentialManager;
use JR::NetUtils::NetUtils;
use JR::Parsers::CLI;

my $VERSION="1.2.0";
my $CONFIG_FILE="/opt/neet/etc/neet.conf";
my $VceCONFIG_FILE="/opt/neet/etc/vce.conf";

if (-f "$ENV{'HOME'}/.neet/vce.conf"){
	$VceCONFIG_FILE="$ENV{'HOME'}/.neet/vce.conf";
}
if (-f "$ENV{'HOME'}/.neet/neet.conf"){
	$CONFIG_FILE="$ENV{'HOME'}/.neet/neet.conf";
}

my $Config=Config->new($CONFIG_FILE);
my $Vce=Neet::VceConfig->new($VceCONFIG_FILE);
if (!$Config || !$Vce){
	die "Couldn't read config file $CONFIG_FILE or $VceCONFIG_FILE\n";
}

# Logging
my $logfile="exploit.log";

my $Log=Neet::Logging->new();
# Sort out the colouring
my $InverseVideo = $Config->GetVal("InverseVideo");
if ($InverseVideo && ($InverseVideo == 1)){
	$Log->AltColour(1);
}

$Log->LogFile("logs/$logfile");
#if (-f "logs/$logfile"){
#	system ("cat logs/$logfile >> logs/${logfile}-archive && rm logs/$logfile");
#}
$Log->OpenLog;
$Log->Info ("[$$] This is neet_exploit $VERSION in \"$ENV{'PWD'}\"\n","LOGONLY");

# Credential database
my $credentialManager=Neet::CredentialManager->new();

my ($safeMode,$exploitable,$exploited)=(1,0,0);
my ($Target,@vulnFile,$Interface,$Architecture,$OS);

my $BasePrefix=$Config->GetVal("BasePrefix");

# Where's metasploit?
my $msf2dir="${BasePrefix}/pkg/framework2";
my $msf2cli="${msf2dir}/msfcli";
#my $msfdir="${BasePrefix}/pkg/framework3";
#my $msfcli="${msfdir}/msfcli";

my $msfdir="/opt/metasploit";
my $msfcli="${msfdir}/app/msfcli";

# Where are our internal commands?
my $bindir="${BasePrefix}/pkg/bin/";

# Command line
my $CLI=JR::Parsers::CLI->new('uh:');
$CLI->Process(@ARGV);
if ($CLI->Got('u')){
	$safeMode=0;
}

if ($CLI->Got('h')){
	my $val=$CLI->Value('h');
	if (IsIPSpec($val)){
		$Target=$val;
	}
}

if (!$Target){
	$Log->Warn("[$$] No valid IP address specified\n");
	exit 1;
}

$Log->Info("[$$] Target: $Target\n","LOGONLY");
if (open(FH,"vulnerabilities.txt")){
	@vulnFile=<FH>;
	close FH;
}

# Get interface, architecture and OS
if (open(FH,"${Target}/hostInfo.txt")){
	until (eof FH){
		my $line=readline(*FH);
		chomp $line;
		my $junk;
		if ($line =~ /^ReachedBy /){
			($junk,$Interface)=split (" ", $line, 2);
		}
		if ($line =~ /^Architecture /){
			($junk,$Architecture)=split (" ", $line, 2);
		}
		if ($line =~ /^OS /){
			($junk,$OS)=split (" ", $line, 2);
		}
	}
	close FH;
}

# Cycle through the vulnerabilities, offering suitable exploits to the user.
for my $vuln (@vulnFile){
	next if ($vuln !~ /^$Target\D/);
	my ($type,$name,$desc,$msref,$cve,$bid,$chType,$exType,$exSafe,$exArch);
	my ($targ,$label,$junk)=split ("\\s",$vuln,3);
	my $check=labelID($label);
	$name=$Vce->Name("$check");
	$type=$Vce->Type("$check");
	$label=$Vce->Label("$check");
	$desc=$Vce->Desc("$check");
	$msref=$Vce->Msref("$check");
	$cve=$Vce->Cve("$check");
	$bid=$Vce->Bid("$check");
	$exType=$Vce->Extype("$check");
	$exSafe=$Vce->Exmanusafe("$check");
	$exArch=$Vce->Exarch("$check");
	$exArch="" if (!$exArch);

	if ($exType){
		next if ($type eq "FILECHECK");
		if ($safeMode && ("$exSafe" eq "0")){
			$Log->Info("[$$] Not exploiting $desc - exploit marked unsafe, and safe mode is enabled\n","LOGONLY");
		} else {
			$exploitable++;
			if ($msref){
				$Log->Warn ("[$$] Exploit $exArch $desc ($msref) on $Target? [y/N]\n");
			} else {
				$Log->Warn ("[$$] Exploit $exArch $desc ($name) on $Target? [y/N]\n");
			}
			if (GetKey() !~ /Y/i){
				$Log->Info ("[$$] Not Exploiting\n");
			} elsif ($exType =~ /metasploit/) {
				my $result=MsfExploit ($Target, $check, $Interface, $Architecture, $OS, $exArch);
				# Once we've exploited something, don't carry on offering more opportunities - the box will end up like swiss cheese.
				# Stop here. If the user wants to carry on, he can run this again, and pick a different one.
				$exploited=1;
				last;
			} elsif ($exType eq "exec") {
				my $result=ExecExploit ($Target, $check, $Interface);
				# Once we've exploited something, don't carry on offering more opportunities - the box will end up like swiss cheese.
				# Stop here. If the user wants to carry on, he can run this again, and pick a different one.
				$exploited=1;
				last;
			}
		}
	}
}

sub labelID {
	my $label=shift();
	for (my $i=0; $i<=$Vce->totalChecks; $i++){
		if ($Vce->Label($i) && $Vce->Label($i) eq "$label"){
			return $i;
		}
	}
}

# Now cycle through the possible exploits listed in the file and see if we're vulnerable
for my $check ($Vce->Checks("FILECHECK")){
	last if ($exploited);
	my $name=$Vce->Name("$check");
	my $desc=$Vce->Desc("$check");
	my $test=$Vce->Check("$check");
	my $vuln=$Vce->Vuln("$check");
	my $label=$Vce->Label("$check");
	my $exType=$Vce->Extype("$check");
	my $exSafe=$Vce->Exmanusafe("$check");
	my $credType=$Vce->Credentialtype("$check");

	$vuln =~ s/HOST/$Target/g;

	if ($test && -f "$test"){
		my @file;
		if (open(F,"$test")){
			@file=<F>;
			close F;
		}
		for my $line (@file){
			if ($line =~ /$vuln/){
				if ($safeMode && ("$exSafe" eq "0")){
					$Log->Info("[$$] Not exploiting $desc - exploit marked unsafe, and safe mode is enabled\n","LOGONLY");
				} else {
					$exploitable++;
					chomp $line;
					my ($ip,$protocol,$port);
					my ($target,$service)=split "\\s", $line;					
					if ($target && $target =~ /:/){
						($ip,$port)=split ":", $target;
						if ($port =~ /\//){
							($protocol,$port)=split ("\\/", $port);
						}
					}

					my ($user,$pass);

					if ($credType){
						# Get the username and password from the credential manager
						my @results=$credentialManager->selectCredentials(
						 'type'=>$credType,'system'=>$ip,'output'=>'up'
						);
						next if ($#results == -1);

						for my $credential (@results){
							$user = $$credential{'user'};
							$pass = $$credential{'pass'};
							last;
						}
					}

	 				if ($exType){
						$Log->Warn ("[$$] Exploit $desc ($name) on $Target? [y/N]\n");
						if (GetKey() !~ /Y/i){
							$Log->Info ("[$$] Not Exploiting\n");
						} elsif ($exType eq "intpwgexec") {

							my $result=IntPwgExploit ($Target, $check, $Interface, $user,"$pass",$port);
							# Once we've exploited something, don't carry on offering more opportunities - the box will end up like swiss cheese.
							# Stop here. If the user wants to carry on, he can run this again, and pick a different one.
							last;
							$exploited=1;
						} elsif ($exType eq "exec") {
							my $result=ExecExploit ($Target, $check, $Interface);
							# Once we've exploited something, don't carry on offering more opportunities - the box will end up like swiss cheese.
							# Stop here. If the user wants to carry on, he can run this again, and pick a different one.
							$exploited=1;
							last;
						}
					}
				}
			}
		}
	}
}

if (!$exploitable){
	$Log->Info("[$$] No exploitable vulnerabilities found for $Target\n");
}

$Log->CloseLog;

sub IntPwgExploit {
	my ($host,$check,$Interface,$user,$pass,$port)=@_;
	my $name=$Vce->Name("$check");
	my $desc=$Vce->Desc("$check");
	my $label=$Vce->Label("$check");
	my $xterm=$Vce->Xterm("$check");
	my $extype=$Vce->Extype("$check");

	my $exploitcmd=$Vce->Exmancmd("$check");
	return 0 if (!$exploitcmd);
	$Log->Warn("[$$] Exploiting $desc on $host\n");
	my $target=0;

	my $localaddr=InterfaceIP($Interface);
	my $LocalPort=int(rand(50000))+10000;

	$exploitcmd =~ s/HOST/$host/g; $exploitcmd =~ s/\[LOCAL\]/$localaddr/g; $exploitcmd =~ s/\[LOCALPORT\]/$LocalPort/g; $exploitcmd =~ s/\[BIN\]/$bindir/g;
	$exploitcmd =~ s/\[USERNAME\]/$user/g; $exploitcmd =~ s/\[PASSWORD\]/\"$pass\"/g; $exploitcmd =~ s/PORT/$port/g; $exploitcmd =~ s/MSF2CLI/$msf2cli/g; $exploitcmd =~ s/MSFCLI/$msfcli/g;

	my $cmd;
	if (!defined($xterm) || ($xterm ne "no")){
		$cmd=$Config->GetVal("ExploitationTerminal");
		$cmd =~ s?TITLE?"Exploit -> $host ($name)"?g;
		$cmd =~ s?MONITOR?${bindir}$exploitcmd >/dev/null 2>&1 &?g;
	} else {
		$cmd="${bindir}$exploitcmd";
	}
	$Log->Exec ("PID $$ Executing: $cmd\n");
	#print "Executing $cmd\n";
	system("$cmd");
	return 0;
}

sub ExecExploit {
	my ($host,$check,$Interface,$port)=@_;
	my $name=$Vce->Name("$check");
	my $desc=$Vce->Desc("$check");
	my $udpport=$Vce->Udpport("$check");
	my $tcpport=$Vce->Tcpport("$check");
	my $xterm=$Vce->Xterm("$check");

	my $exploitcmd=$Vce->Exmancmd("$check");
	return 0 if (!$exploitcmd);
	$Log->Warn("[$$] Exploiting $desc on $host\n");
	my $target=0;

	my $localaddr=InterfaceIP($Interface);
	my $LocalPort=int(rand(50000))+10000;

	if (!$port){
		if ($tcpport){
			if (open(F,"$ENV{'PWD'}/$host/tcpports.txt")){
				my @file=<F>;
				close F;
				for my $line (@file){
					if ($line =~ /^\d+ $tcpport\s/){
						$port=$line;
						$port =~ s/^(\d+)\s[\S\s]+/$1/;
						last;
					}
				}
				$#file=-1;
			}
		} elsif ($udpport) {
			if (open(F,"$ENV{'PWD'}/$host/udpports.txt")){
				my @file=<F>;
				close F;
				for my $line (@file){
					if ($line =~ /^\d+ $udpport\s/){
						$port=$line;
						$port =~ s/^(\d+)\s[\S\s]+/$1/;
						last;
					}
				}
				$#file=-1;
			}
		}
	}
	$exploitcmd =~ s/HOST/$host/g; $exploitcmd =~ s/\[LOCAL\]/$localaddr/g; $exploitcmd =~ s/\[LOCALPORT\]/$LocalPort/g; $exploitcmd =~ s/\[BIN\]/$bindir/g;
	$exploitcmd =~ s/PORT/$port/g; $exploitcmd =~ s/MSF2CLI/$msf2cli/g; $exploitcmd =~ s/MSFCLI/$msfcli/g;

	my $cmd;
	if (!defined($xterm) || ($xterm ne "no")){
		$cmd=$Config->GetVal("ExploitationTerminal");
		$cmd =~ s?TITLE?"Exploit -> $host ($name)"?g;
		$cmd =~ s?MONITOR?$exploitcmd >/dev/null 2>&1 &?g;
	} else {
		$cmd=$exploitcmd;
	}
	$Log->Exec ("PID $$ Executing: $cmd\n");
	#print "Executing $cmd\n";
	system("$cmd");
	return 0;
}


sub MsfExploit {
	my ($host,$check,$Interface,$Architecture,$OS,$exArch)=@_;
	my $name=$Vce->Name("$check");
	my $desc=$Vce->Desc("$check");
	my $xterm=$Vce->Xterm("$check");
	my $extype=$Vce->Extype("$check");

	# Don't run 32-bit exploits on 64-bit architecture
	if ($Architecture && ($Architecture !~ /$exArch/)){
		$Log->Warn("[$$] Not running $exArch exploit on $Architecture architecture!\n");
		return 0;
	}

	my $exploitcmd=$Vce->Exmancmd("$check");
	$Log->Warn("[$$] Exploiting $desc on $host\n");
	my $target=0;

	if ($exploitcmd =~ /\[AUTOTARGET\]/){
		$target=autoTarget ($check,$OS);
		if (!defined($target)){
			$Log->Warn("[$$] Couldn't determine target for $desc on $host ($OS)\n");
			return 0;
		}
		$exploitcmd =~ s/\[AUTOTARGET\]/$target/g;
	}

	my $localaddr=InterfaceIP($Interface);
	my $LocalPort=int(rand(50000))+10000;

	$exploitcmd =~ s/=HOST/=$host/g; $exploitcmd =~ s/\[LOCAL\]/$localaddr/g; $exploitcmd =~ s/\[LOCALPORT\]/$LocalPort/g; $exploitcmd =~ s/MSF2CLI/$msf2cli/g; $exploitcmd =~ s/MSFCLI/$msfcli/g;

	my $cmd;
	if (!defined($xterm) || ($xterm ne "no")){
		$cmd=$Config->GetVal("ExploitationTerminal");
		$cmd =~ s?TITLE?"Exploit -> $host ($name)"?g;

		if ($extype =~ /2/){
			$cmd =~ s?MONITOR?${msf2cli} $exploitcmd >/dev/null 2>&1 &?g;
 		} else {
			$cmd =~ s?MONITOR?/bin/sh -c "cd ${msfdir} && ./app/msfcli $exploitcmd" &?g;
		}
	} else {
		if ($extype =~ /2/){
			$cmd="$msf2cli $exploitcmd";
		} else {
			$cmd="cd ${msfdir} && ./msfcli $exploitcmd";
		}
	}
	$Log->Exec ("PID $$ Executing: $cmd\n");
	#print "Executing $cmd\n";
	system("$cmd");
	return 0;
}

sub autoTarget {
	my $check=shift();
	my $OS=shift(); $OS=~s/\sSP\d//g; $OS=~s/\s//g;
	my $t=$Vce->GetVal($check,"extarget.$OS");
	$Log->Info ("Auto-selected target $t ($OS)\n","LOGONLY");
	return $t;
}

